#pragma once

#include "domain/events/EventBus.h"
#include "domain/events/Event.h"
#include "domain/events/ScoreUpdatedEvent.h"
#include "domain/music/Score.h"
#include "utils/TrackedLock.h"
#include <memory>
#include <shared_mutex>
#include <atomic>

namespace music::statesync {

class StateSynchronizationManager {
public:
	explicit StateSynchronizationManager(events::EventBus& eventBus);
	
	void synchronize(const Score& score) {
		auto snapshot = score.createSnapshot();
		auto version = versionCounter.fetch_add(1, std::memory_order_relaxed);
		auto event = std::make_unique<events::ScoreUpdatedEvent>(snapshot, version);
		
		{
			::utils::TrackedUniqueLock lock(mutex_, "StateSynchronizationManager::mutex_", ::utils::LockLevel::VALIDATION);
			eventBus.publish(std::move(event));
		}
	}

#ifdef TESTING
	std::shared_mutex& getMutexForTesting() const { return mutex_; }
#endif

private:
	events::EventBus& eventBus;
	std::atomic<uint64_t> versionCounter{0};
	mutable std::shared_mutex mutex_; // Level VALIDATION (3)
};

} // namespace music::statesync